/** @module api/github */
"use strict";

/*
 * Imports
 */
const
    debug = require('debug')('bakery:lib:github'),
    feedback = require('./feedback'),
    github = require('octonode'),
    NodeGit = require('nodegit'),
    path = require('path'),
    net = require('net');

const HTTPS_PORT = 443;
const CONNECTION_TIMEOUT = 5000;

/*
 * Constants
 */
let accessToken = process.env.GITHUB_API_ACCESS_TOKEN;
let ghHostname = process.env.GITHUB_HOSTNAME || 'github.com';
let apiHostname = ghHostname + "/api/v3";

var GithubHandler = function(options) {
  // Only really care about these properties

  if (options.generator) {

    this.username = options.generator.answers.githubUser;
    this.reponame = options.generator.answers.appname;
    this.org = options.generator.answers.organization;
  }
  else {
    this.username = options.username;
    this.reponame = options.reponame;
    this.org = options.org;
  }

  this.client = options.client;

  var ghme = this.client.me();
  this.shouldFork = false;
  this.shouldPush = true;
  this.create = ghme.repo.bind(ghme);
  this.createParams = {
    "name":        options.reponame,
    "description": "Generated by the AMI Bakery!",
  };
};

function getGitUser() {
  if (! accessToken) {
    return Promise.resolve();
  }

  let ghclient = github.client(accessToken, {hostname: apiHostname})
  return new Promise((resolve, reject) => {
    ghclient.me().info(function(err, data, headers) {
      if (err) {
        return reject(err);
      }
      resolve(data);
    });
  });
}

function testConnection() {
  feedback.info("Testing connection to GitHub");
  return new Promise((resolve, reject) => {
    const socket = net.connect(HTTPS_PORT, ghHostname, () => {
      socket.destroy();
      resolve();
    });
    socket.setTimeout(CONNECTION_TIMEOUT);
    socket.on('timeout', _ => {
      socket.destroy();
      return reject(new Error("Check your VPN yo!"));
    });
  });
}

/**
 * Run the "publish" command. Creates a github repo if one doesn't exist and adds a remote to that repo if one does.
 *
 * @param {object} generator - used to create the app
 * @returns {Promise.<generators.Base>} generator
 */
function publishToGithub(generator) {
  debug('Connecting to GitHub at %j with token %j', apiHostname, accessToken);
  return createRepository(generator)
      .then(_ => generator)
      .catch((err) => {
        if (err.body) {
          debug('Publish to Github failed', err.body);
        }
        throw err;
      })
}

/**
 * Creates a github repository in the given organization (if it exists) and on the given user with the given name
 *
 * @param {Object} generator reference to Yeoman generator instance
 * @return {Promise.<object>} handler object containing the github client and the yeoman generator
 */
function createRepository(generator) {
  let ghclient = github.client(accessToken, {hostname: apiHostname})
  let handler = new GithubHandler({'generator': generator, 'client': ghclient});

  return createOrgRepository(handler).then(createUserRepository);
}

/**
 * Creates a github repository in the user space. The user is derived from generator.answers.githubUser
 *
 * @param {Object} handler Map with octonode client instance and yeoman generator instance
 * @return {Promise.<object>} handler
 */
function createUserRepository(handler) {
  let userHandler = new GithubHandler(handler); // Be immutable
  let ghme = userHandler.client.me();
  userHandler.create = ghme.repo.bind(ghme);

  debug('Working on GitHub user repository');

  return getRepoInfoByOrg(userHandler)
      .then((exists) => shouldForkOrCreate(userHandler, exists))
      .then(getRepoInfoByUser)
      .then((exists) => {
        if (exists) {
          feedback.notice('A repo already exists for %s. Skipping...', userHandler.reponame)
          return userHandler;
        }
        else {
          return promiseRepository(userHandler);
        }
      })
      .then(assignOriginRemote)
      .then(pushToRemote);
}

function pushToRemote(handler) {

  if (! handler.shouldPush) {
    return Promise.resolve(handler);
  }
  // handle pushing
  let remote = handler.remote;
  feedback.notice('Pushing to %j', remote.name());

  return remote.push(
      ["refs/heads/master:refs/heads/master"],
      {
        callbacks: {
          credentials: function(url, userName) {
            return NodeGit.Cred.userpassPlaintextNew(accessToken, 'x-oauth-basic');
          }
        }
      }
  ).then(_ => handler);
}

/**
 * Determines if repository forking or creation is necessary. If the repository exists in an organization,
 * we fork; otherwise, we create. EZ PZ. bound function reference directed to a forking or creating function
 * is set on handler.forkOrCreate
 *
 *
 * @param {boolean} exists whether the repository exists in an organization or not.
 * @return {object} handler with forkOrCreate property set
 */
function shouldForkOrCreate(handler, exists) {
  let ghme = handler.client.me();
  let ghuser = handler.client.user(handler.username);

  if (exists) {
    feedback.info("Choosing to fork repo %s from %s", handler.reponame, handler.org);
    handler.createParams = handler.org + "/" + handler.reponame;
    handler.create = ghme.fork.bind(ghme);
    handler.shouldFork = true;
    handler.shouldPush = false;
    return handler;
  }

  handler.create = ghme.repo.bind(ghme);
  return handler;
}

/**
 *
 * @param {Object} handler Map with octonode client instance and yeoman generator instance
 */
function resolveResponse(handler, exec) {
  return new Promise((resolve, reject) => {
    exec((err, data, headers) => {
      if (err) {
        if (err.statusCode === 404)
          return resolve(null);

        if (err.body)
          debug('Github reponse body: ', err.body);

        return reject(err);
      }
      resolve(data);
    });
  });
}

/**
 *
 * @param {Object} handler Map with octonode client instance and yeoman generator instance
 */
function getRepoInfoByUser(handler) {
  let ghuser = handler.client.repo(handler.username + '/' + handler.reponame);
  return resolveResponse(handler, ghuser.info.bind(ghuser));
}

/**
 *
 * @param {Object} handler Map with octonode client instance and yeoman generator instance
 */
function getRepoInfoByOrg(handler) {
  let ghorg = handler.client.repo(handler.org + '/' + handler.reponame);
  return resolveResponse(handler, ghorg.info.bind(ghorg));
}

/**
 * Create a repository within an organization. The organization is derived from generator.answers.organization
 *
 * @param {Object} handler Map with octonode client instance and yeoman generator instance
 * @return {Promise.<object>} handler
 */
function createOrgRepository(handler) {
  let orgHandler = new GithubHandler(handler); // Be immutable
  let ghorg = orgHandler.client.org(orgHandler.org);
  orgHandler.create = ghorg.repo.bind(ghorg);

  if (orgHandler.org) {
    debug('Working on GitHub organization repository');
    return getRepoInfoByOrg(orgHandler)
        .then((exists) => exists ? feedback.notice('A repo already exists for %s. Skipping...', orgHandler.reponame) : exists)
        .then((exists) => {
          if (exists) {
            orgHandler.shouldPush = false;
            return orgHandler;
          }
          return promiseRepository(orgHandler);
        })
        .then(assignUpstreamRemote)
        .then(pushToRemote)
        .then((_) => orgHandler);
  }

  debug('No GitHub organization in use');
  return Promise.resolve(handler); // Nothing but empty promises
}

/**
 * Create a new repository if one does not already exist.
 *
 * @param {object} handler
 * @return {Promise.<object>} handler
 */
function promiseRepository(handler) {
  return new Promise((resolve, reject) => {

    if (handler.shouldFork) {
      feedback.notice("Forking Github repository %s to %s", handler.createParams, handler.reponame);
    }
    else {
      feedback.notice("Creating Github repository %s", handler.reponame);
    }

    let createFunc = handler.create;

    createFunc(handler.createParams, function(err, data, headers) {
      if (err) {
        return reject(err);
      }
      return resolve(handler);
    }); //repo
  });
}

function promiseRemote(pathToRepo, remote, url) {
  return NodeGit.Repository.open(pathToRepo).then((repository) => {
    return NodeGit.Remote.list(repository)
        .then((array) => checkRepoExists(array, remote))
        .then((exists) => addRemote(exists, repository, remote, url))
  });
}

function addRemote(exists, repository, remote, url) {
  if (exists) {
    feedback.info('A remote for %s already exists. Skipping...', remote);
    return NodeGit.Remote.lookup(repository, remote);
  }
  else {
    feedback.info('Assigning remote for %s to %s', url, remote)
    return NodeGit.Remote.create(repository, remote, url);
  }
}

function checkRepoExists(repoArr, repo) {
  let exists = false;
  for (var idx in repoArr) {
    exists |= (repo === repoArr[idx])
  }

  return exists;
}

function assignOriginRemote(handler) {
  var pathToRepo = path.resolve("../" + handler.reponame);
  const repoUrl = buildRemoteUrl(handler.username, handler.reponame);

  return promiseRemote(pathToRepo, "origin", repoUrl)
      .then((remote) => handler.remote = remote)
      .then(_ => handler);
}

function assignUpstreamRemote(handler) {
  debug("Assigning upstream remote");
  var pathToRepo = path.resolve("../" + handler.reponame);

  if (handler.org) {
    const repoUrl = buildRemoteUrl(handler.org, handler.reponame);
    return promiseRemote(pathToRepo, "upstream", repoUrl)
        .then((remote) => handler.remote = remote)
        .then(_ => handler);
  }

  return Promise.resolve(handler); // Nothing but empty promises
}

/**
 * Assign a remote
 *
 * @param {Object} handler - url to assign
 * @return {Promise.<object>} handler
 */
function assignRemotes(handler) {
  return assignOriginRemote(handler)
      .then(assignUpstreamRemote)
}

/**
 * Constructs a URL that will be used as a gitremote
 *
 * @param {String} owner could be a username or organization name
 * @param {String} name of the repository
 * @return {String} url used for git remote
 */
function buildRemoteUrl(owner, name) {
  return "https://" + ghHostname + "/" + owner + "/" + name;
  // return 'git@' + ghHostname + ':' + owner + '/' + name
}

function gitOptions() {
  return {
    fetchOpts: {
      callbacks: {
        certificateCheck: function () {
          return 1;
        },
        credentials: function () {
          return NodeGit.Cred.userpassPlaintextNew(accessToken, 'x-oauth-basic');
        }
      }
    }
  }
}

/**
 * Clone the project using branch name
 *
 * @param {String} answers
 * @param {String} dir
 * @return {String} branch
 */
function gitClone(answers, dir, branch) {
  const opts = gitOptions();
  if (branch)
    opts.checkoutBranch = branch;

  debug('Clone: creating clone at: %j', dir);
  return NodeGit.Clone(buildRemoteUrl(answers.organization, answers.reponame), dir, opts);
}

function trimSHA(data) {
  return data && data.commit && data.commit.sha ? data.commit.sha.substring(0, 7) : '';
}

/**
 * Returns SHA number of last commit for the repository
 *
 * @param {String} repository name
 * @param {String} branch name
 */
function gitLastCommit(repo, branch) {
  if (!accessToken) {
    return Promise.resolve();
  }

  let ghclient = github.client(accessToken, { hostname: apiHostname });

  return new Promise((resolve, reject) => {

    ghclient.repo(repo.organization + '/' + repo.reponame).branch(branch.trim(), function (err, data, headers) {
      if (err) {
        return reject(err);
      }
      resolve(trimSHA(data));
    });
  });
}

module.exports = {
  publishToGithub,
  GithubHandler,
  getGitUser,
  testConnection,
  gitClone,
  gitLastCommit
};
